/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Assembly Writer Source Fragment                                            *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|* From: Rymo.td                                                              *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

/// getMnemonic - This method is automatically generated by tablegen
/// from the instruction set description.
std::pair<const char *, uint64_t> RymoInstPrinter::getMnemonic(const MCInst *MI) {

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Woverlength-strings"
#endif
  static const char AsmStrs[] = {
  /* 0 */ "addi \0"
  /* 6 */ "li \0"
  /* 10 */ "fmul \0"
  /* 16 */ "jalr \0"
  /* 22 */ "# XRay Function Patchable RET.\0"
  /* 53 */ "# XRay Typed Event Log.\0"
  /* 77 */ "# XRay Custom Event Log.\0"
  /* 102 */ "# XRay Function Enter.\0"
  /* 125 */ "# XRay Tail Call Exit.\0"
  /* 148 */ "# XRay Function Exit.\0"
  /* 170 */ "LIFETIME_END\0"
  /* 183 */ "PSEUDO_PROBE\0"
  /* 196 */ "BUNDLE\0"
  /* 203 */ "DBG_VALUE\0"
  /* 213 */ "DBG_INSTR_REF\0"
  /* 227 */ "DBG_PHI\0"
  /* 235 */ "DBG_LABEL\0"
  /* 245 */ "LIFETIME_START\0"
  /* 260 */ "DBG_VALUE_LIST\0"
  /* 275 */ "# FEntry call\0"
};
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

  static const uint16_t OpInfo0[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// INLINEASM_BR
    0U,	// CFI_INSTRUCTION
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// ANNOTATION_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    204U,	// DBG_VALUE
    261U,	// DBG_VALUE_LIST
    214U,	// DBG_INSTR_REF
    228U,	// DBG_PHI
    236U,	// DBG_LABEL
    0U,	// REG_SEQUENCE
    0U,	// COPY
    197U,	// BUNDLE
    246U,	// LIFETIME_START
    171U,	// LIFETIME_END
    184U,	// PSEUDO_PROBE
    0U,	// ARITH_FENCE
    0U,	// STACKMAP
    276U,	// FENTRY_CALL
    0U,	// PATCHPOINT
    0U,	// LOAD_STACK_GUARD
    0U,	// PREALLOCATED_SETUP
    0U,	// PREALLOCATED_ARG
    0U,	// STATEPOINT
    0U,	// LOCAL_ESCAPE
    0U,	// FAULTING_OP
    0U,	// PATCHABLE_OP
    103U,	// PATCHABLE_FUNCTION_ENTER
    23U,	// PATCHABLE_RET
    149U,	// PATCHABLE_FUNCTION_EXIT
    126U,	// PATCHABLE_TAIL_CALL
    78U,	// PATCHABLE_EVENT_CALL
    54U,	// PATCHABLE_TYPED_EVENT_CALL
    0U,	// ICALL_BRANCH_FUNNEL
    0U,	// MEMBARRIER
    0U,	// JUMP_TABLE_DEBUG_INFO
    0U,	// CONVERGENCECTRL_ENTRY
    0U,	// CONVERGENCECTRL_ANCHOR
    0U,	// CONVERGENCECTRL_LOOP
    0U,	// CONVERGENCECTRL_GLUE
    0U,	// G_ASSERT_SEXT
    0U,	// G_ASSERT_ZEXT
    0U,	// G_ASSERT_ALIGN
    0U,	// G_ADD
    0U,	// G_SUB
    0U,	// G_MUL
    0U,	// G_SDIV
    0U,	// G_UDIV
    0U,	// G_SREM
    0U,	// G_UREM
    0U,	// G_SDIVREM
    0U,	// G_UDIVREM
    0U,	// G_AND
    0U,	// G_OR
    0U,	// G_XOR
    0U,	// G_IMPLICIT_DEF
    0U,	// G_PHI
    0U,	// G_FRAME_INDEX
    0U,	// G_GLOBAL_VALUE
    0U,	// G_PTRAUTH_GLOBAL_VALUE
    0U,	// G_CONSTANT_POOL
    0U,	// G_EXTRACT
    0U,	// G_UNMERGE_VALUES
    0U,	// G_INSERT
    0U,	// G_MERGE_VALUES
    0U,	// G_BUILD_VECTOR
    0U,	// G_BUILD_VECTOR_TRUNC
    0U,	// G_CONCAT_VECTORS
    0U,	// G_PTRTOINT
    0U,	// G_INTTOPTR
    0U,	// G_BITCAST
    0U,	// G_FREEZE
    0U,	// G_CONSTANT_FOLD_BARRIER
    0U,	// G_INTRINSIC_FPTRUNC_ROUND
    0U,	// G_INTRINSIC_TRUNC
    0U,	// G_INTRINSIC_ROUND
    0U,	// G_INTRINSIC_LRINT
    0U,	// G_INTRINSIC_LLRINT
    0U,	// G_INTRINSIC_ROUNDEVEN
    0U,	// G_READCYCLECOUNTER
    0U,	// G_READSTEADYCOUNTER
    0U,	// G_LOAD
    0U,	// G_SEXTLOAD
    0U,	// G_ZEXTLOAD
    0U,	// G_INDEXED_LOAD
    0U,	// G_INDEXED_SEXTLOAD
    0U,	// G_INDEXED_ZEXTLOAD
    0U,	// G_STORE
    0U,	// G_INDEXED_STORE
    0U,	// G_ATOMIC_CMPXCHG_WITH_SUCCESS
    0U,	// G_ATOMIC_CMPXCHG
    0U,	// G_ATOMICRMW_XCHG
    0U,	// G_ATOMICRMW_ADD
    0U,	// G_ATOMICRMW_SUB
    0U,	// G_ATOMICRMW_AND
    0U,	// G_ATOMICRMW_NAND
    0U,	// G_ATOMICRMW_OR
    0U,	// G_ATOMICRMW_XOR
    0U,	// G_ATOMICRMW_MAX
    0U,	// G_ATOMICRMW_MIN
    0U,	// G_ATOMICRMW_UMAX
    0U,	// G_ATOMICRMW_UMIN
    0U,	// G_ATOMICRMW_FADD
    0U,	// G_ATOMICRMW_FSUB
    0U,	// G_ATOMICRMW_FMAX
    0U,	// G_ATOMICRMW_FMIN
    0U,	// G_ATOMICRMW_UINC_WRAP
    0U,	// G_ATOMICRMW_UDEC_WRAP
    0U,	// G_FENCE
    0U,	// G_PREFETCH
    0U,	// G_BRCOND
    0U,	// G_BRINDIRECT
    0U,	// G_INVOKE_REGION_START
    0U,	// G_INTRINSIC
    0U,	// G_INTRINSIC_W_SIDE_EFFECTS
    0U,	// G_INTRINSIC_CONVERGENT
    0U,	// G_INTRINSIC_CONVERGENT_W_SIDE_EFFECTS
    0U,	// G_ANYEXT
    0U,	// G_TRUNC
    0U,	// G_CONSTANT
    0U,	// G_FCONSTANT
    0U,	// G_VASTART
    0U,	// G_VAARG
    0U,	// G_SEXT
    0U,	// G_SEXT_INREG
    0U,	// G_ZEXT
    0U,	// G_SHL
    0U,	// G_LSHR
    0U,	// G_ASHR
    0U,	// G_FSHL
    0U,	// G_FSHR
    0U,	// G_ROTR
    0U,	// G_ROTL
    0U,	// G_ICMP
    0U,	// G_FCMP
    0U,	// G_SCMP
    0U,	// G_UCMP
    0U,	// G_SELECT
    0U,	// G_UADDO
    0U,	// G_UADDE
    0U,	// G_USUBO
    0U,	// G_USUBE
    0U,	// G_SADDO
    0U,	// G_SADDE
    0U,	// G_SSUBO
    0U,	// G_SSUBE
    0U,	// G_UMULO
    0U,	// G_SMULO
    0U,	// G_UMULH
    0U,	// G_SMULH
    0U,	// G_UADDSAT
    0U,	// G_SADDSAT
    0U,	// G_USUBSAT
    0U,	// G_SSUBSAT
    0U,	// G_USHLSAT
    0U,	// G_SSHLSAT
    0U,	// G_SMULFIX
    0U,	// G_UMULFIX
    0U,	// G_SMULFIXSAT
    0U,	// G_UMULFIXSAT
    0U,	// G_SDIVFIX
    0U,	// G_UDIVFIX
    0U,	// G_SDIVFIXSAT
    0U,	// G_UDIVFIXSAT
    0U,	// G_FADD
    0U,	// G_FSUB
    0U,	// G_FMUL
    0U,	// G_FMA
    0U,	// G_FMAD
    0U,	// G_FDIV
    0U,	// G_FREM
    0U,	// G_FPOW
    0U,	// G_FPOWI
    0U,	// G_FEXP
    0U,	// G_FEXP2
    0U,	// G_FEXP10
    0U,	// G_FLOG
    0U,	// G_FLOG2
    0U,	// G_FLOG10
    0U,	// G_FLDEXP
    0U,	// G_FFREXP
    0U,	// G_FNEG
    0U,	// G_FPEXT
    0U,	// G_FPTRUNC
    0U,	// G_FPTOSI
    0U,	// G_FPTOUI
    0U,	// G_SITOFP
    0U,	// G_UITOFP
    0U,	// G_FABS
    0U,	// G_FCOPYSIGN
    0U,	// G_IS_FPCLASS
    0U,	// G_FCANONICALIZE
    0U,	// G_FMINNUM
    0U,	// G_FMAXNUM
    0U,	// G_FMINNUM_IEEE
    0U,	// G_FMAXNUM_IEEE
    0U,	// G_FMINIMUM
    0U,	// G_FMAXIMUM
    0U,	// G_GET_FPENV
    0U,	// G_SET_FPENV
    0U,	// G_RESET_FPENV
    0U,	// G_GET_FPMODE
    0U,	// G_SET_FPMODE
    0U,	// G_RESET_FPMODE
    0U,	// G_PTR_ADD
    0U,	// G_PTRMASK
    0U,	// G_SMIN
    0U,	// G_SMAX
    0U,	// G_UMIN
    0U,	// G_UMAX
    0U,	// G_ABS
    0U,	// G_LROUND
    0U,	// G_LLROUND
    0U,	// G_BR
    0U,	// G_BRJT
    0U,	// G_VSCALE
    0U,	// G_INSERT_SUBVECTOR
    0U,	// G_EXTRACT_SUBVECTOR
    0U,	// G_INSERT_VECTOR_ELT
    0U,	// G_EXTRACT_VECTOR_ELT
    0U,	// G_SHUFFLE_VECTOR
    0U,	// G_SPLAT_VECTOR
    0U,	// G_VECTOR_COMPRESS
    0U,	// G_CTTZ
    0U,	// G_CTTZ_ZERO_UNDEF
    0U,	// G_CTLZ
    0U,	// G_CTLZ_ZERO_UNDEF
    0U,	// G_CTPOP
    0U,	// G_BSWAP
    0U,	// G_BITREVERSE
    0U,	// G_FCEIL
    0U,	// G_FCOS
    0U,	// G_FSIN
    0U,	// G_FTAN
    0U,	// G_FACOS
    0U,	// G_FASIN
    0U,	// G_FATAN
    0U,	// G_FCOSH
    0U,	// G_FSINH
    0U,	// G_FTANH
    0U,	// G_FSQRT
    0U,	// G_FFLOOR
    0U,	// G_FRINT
    0U,	// G_FNEARBYINT
    0U,	// G_ADDRSPACE_CAST
    0U,	// G_BLOCK_ADDR
    0U,	// G_JUMP_TABLE
    0U,	// G_DYN_STACKALLOC
    0U,	// G_STACKSAVE
    0U,	// G_STACKRESTORE
    0U,	// G_STRICT_FADD
    0U,	// G_STRICT_FSUB
    0U,	// G_STRICT_FMUL
    0U,	// G_STRICT_FDIV
    0U,	// G_STRICT_FREM
    0U,	// G_STRICT_FMA
    0U,	// G_STRICT_FSQRT
    0U,	// G_STRICT_FLDEXP
    0U,	// G_READ_REGISTER
    0U,	// G_WRITE_REGISTER
    0U,	// G_MEMCPY
    0U,	// G_MEMCPY_INLINE
    0U,	// G_MEMMOVE
    0U,	// G_MEMSET
    0U,	// G_BZERO
    0U,	// G_TRAP
    0U,	// G_DEBUGTRAP
    0U,	// G_UBSANTRAP
    0U,	// G_VECREDUCE_SEQ_FADD
    0U,	// G_VECREDUCE_SEQ_FMUL
    0U,	// G_VECREDUCE_FADD
    0U,	// G_VECREDUCE_FMUL
    0U,	// G_VECREDUCE_FMAX
    0U,	// G_VECREDUCE_FMIN
    0U,	// G_VECREDUCE_FMAXIMUM
    0U,	// G_VECREDUCE_FMINIMUM
    0U,	// G_VECREDUCE_ADD
    0U,	// G_VECREDUCE_MUL
    0U,	// G_VECREDUCE_AND
    0U,	// G_VECREDUCE_OR
    0U,	// G_VECREDUCE_XOR
    0U,	// G_VECREDUCE_SMAX
    0U,	// G_VECREDUCE_SMIN
    0U,	// G_VECREDUCE_UMAX
    0U,	// G_VECREDUCE_UMIN
    0U,	// G_SBFX
    0U,	// G_UBFX
    519U,	// PseudoLI
    0U,	// PseudoRET
    1537U,	// ADDI
    1547U,	// FMUL
    1553U,	// JALR
  };

  // Emit the opcode for the instruction.
  uint32_t Bits = 0;
  Bits |= OpInfo0[MI->getOpcode()] << 0;
  if (Bits == 0)
    return {nullptr, Bits};
  return {AsmStrs+(Bits & 511)-1, Bits};

}
/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
LLVM_NO_PROFILE_INSTRUMENT_FUNCTION
void RymoInstPrinter::printInstruction(const MCInst *MI, uint64_t Address, raw_ostream &O) {
  O << "\t";

  auto MnemonicInfo = getMnemonic(MI);

  O << MnemonicInfo.first;

  uint32_t Bits = MnemonicInfo.second;
  assert(Bits != 0 && "Cannot print this instruction.");

  // Fragment 0 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 9) & 1) {
    // PseudoLI, ADDI, FMUL, JALR
    printOperand(MI, 0, O);
    O << ", ";
    printOperand(MI, 1, O);
  } else {
    // DBG_VALUE, DBG_VALUE_LIST, DBG_INSTR_REF, DBG_PHI, DBG_LABEL, BUNDLE, ...
    return;
  }


  // Fragment 1 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 10) & 1) {
    // ADDI, FMUL, JALR
    O << ", ";
    printOperand(MI, 2, O);
    return;
  } else {
    // PseudoLI
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *RymoInstPrinter::
getRegisterName(MCRegister Reg, unsigned AltIdx) {
  unsigned RegNo = Reg.id();
  assert(RegNo && RegNo < 6 && "Invalid register number!");


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Woverlength-strings"
#endif
  static const char AsmStrsABIRegAltName[] = {
  /* 0 */ "a0\0"
  /* 3 */ "a1\0"
  /* 6 */ "ra\0"
  /* 9 */ "zero\0"
  /* 14 */ "sp\0"
};
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

  static const uint8_t RegAsmOffsetABIRegAltName[] = {
    9, 6, 14, 0, 3, 
  };


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Woverlength-strings"
#endif
  static const char AsmStrsNoRegAltName[] = {
  /* 0 */ "x10\0"
  /* 4 */ "x0\0"
  /* 7 */ "x11\0"
  /* 11 */ "x1\0"
  /* 14 */ "x2\0"
};
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

  static const uint8_t RegAsmOffsetNoRegAltName[] = {
    4, 11, 14, 0, 7, 
  };

  switch(AltIdx) {
  default: llvm_unreachable("Invalid register alt name index!");
  case Rymo::ABIRegAltName:
    assert(*(AsmStrsABIRegAltName+RegAsmOffsetABIRegAltName[RegNo-1]) &&
           "Invalid alt name index for register!");
    return AsmStrsABIRegAltName+RegAsmOffsetABIRegAltName[RegNo-1];
  case Rymo::NoRegAltName:
    assert(*(AsmStrsNoRegAltName+RegAsmOffsetNoRegAltName[RegNo-1]) &&
           "Invalid alt name index for register!");
    return AsmStrsNoRegAltName+RegAsmOffsetNoRegAltName[RegNo-1];
  }
}

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

bool RymoInstPrinter::printAliasInstr(const MCInst *MI, uint64_t Address, raw_ostream &OS) {
  static const PatternsForOpcode OpToPatterns[] = {
    {Rymo::ADDI, 0, 1 },
    {Rymo::JALR, 1, 1 },
  };

  static const AliasPattern Patterns[] = {
    // Rymo::ADDI - 0
    {0, 0, 3, 2 },
    // Rymo::JALR - 1
    {10, 2, 3, 3 },
  };

  static const AliasPatternCond Conds[] = {
    // (ADDI GPR:$rd, X0, i32imm:$imm) - 0
    {AliasPatternCond::K_RegClass, Rymo::GPRRegClassID},
    {AliasPatternCond::K_Reg, Rymo::X0},
    // (JALR X0, X1, 0) - 2
    {AliasPatternCond::K_Reg, Rymo::X0},
    {AliasPatternCond::K_Reg, Rymo::X1},
    {AliasPatternCond::K_Imm, uint32_t(0)},
  };

  static const char AsmStrings[] =
    /* 0 */ "li $\x01, $\x03\0"
    /* 10 */ "ret\0"
  ;

#ifndef NDEBUG
  static struct SortCheck {
    SortCheck(ArrayRef<PatternsForOpcode> OpToPatterns) {
      assert(std::is_sorted(
                 OpToPatterns.begin(), OpToPatterns.end(),
                 [](const PatternsForOpcode &L, const PatternsForOpcode &R) {
                   return L.Opcode < R.Opcode;
                 }) &&
             "tablegen failed to sort opcode patterns");
    }
  } sortCheckVar(OpToPatterns);
#endif

  AliasMatchingData M {
    ArrayRef(OpToPatterns),
    ArrayRef(Patterns),
    ArrayRef(Conds),
    StringRef(AsmStrings, std::size(AsmStrings)),
    nullptr,
  };
  const char *AsmString = matchAliasPatterns(MI, nullptr, M);
  if (!AsmString) return false;

  unsigned I = 0;
  while (AsmString[I] != ' ' && AsmString[I] != '\t' &&
         AsmString[I] != '$' && AsmString[I] != '\0')
    ++I;
  OS << '\t' << StringRef(AsmString, I);
  if (AsmString[I] != '\0') {
    if (AsmString[I] == ' ' || AsmString[I] == '\t') {
      OS << '\t';
      ++I;
    }
    do {
      if (AsmString[I] == '$') {
        ++I;
        if (AsmString[I] == (char)0xff) {
          ++I;
          int OpIdx = AsmString[I++] - 1;
          int PrintMethodIdx = AsmString[I++] - 1;
          printCustomAliasOperand(MI, Address, OpIdx, PrintMethodIdx, OS);
        } else
          printOperand(MI, unsigned(AsmString[I++]) - 1, OS);
      } else {
        OS << AsmString[I++];
      }
    } while (AsmString[I] != '\0');
  }

  return true;
}

void RymoInstPrinter::printCustomAliasOperand(
         const MCInst *MI, uint64_t Address, unsigned OpIdx,
         unsigned PrintMethodIdx,
         raw_ostream &OS) {
  llvm_unreachable("Unknown PrintMethod kind");
}

#endif // PRINT_ALIAS_INSTR
